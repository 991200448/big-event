# 环境准备

## 创建vue工程

 ```SHELL
 # 创建vue工程
 npm init vue@latest
 # 跳转到项目路径
 cd big-event
 # 读取 package.json 文件里的 dependencies 和 devDependencies 字段，然后安装这些字段中列出的所有依赖包到项目的 node_modules 目录下
 npm install
 ```

## 安装依赖

```shell
# 安装element-plus
npm install element-plus --save
# 安装axios
npm install axios
# 安装sass依赖
npm install sass -D
```

> 在main.js中导入element-plus依赖

```JS
// 导入项目的全局样式文件
import './assets/main.scss'
// 从 'vue' 库中导入 createApp 函数，用于创建 Vue 应用实例
import { createApp } from 'vue'
// 导入 ElementPlus 组件库
import ElementPlus from 'element-plus'
// 导入 ElementPlus 组件库的样式文件
import 'element-plus/dist/index.css'
// 导入根组件 App
import App from './App.vue'
// 创建 Vue 应用实例
const app = createApp(App);
// 使用 ElementPlus 插件
app.use(ElementPlus);
// 将 Vue 应用挂载到 id 为 'app' 的 DOM 元素上
app.mount('#app');
```

## 目录调整

删除自动生成的内容

 ```txt
 src/components下面的所有文件
 ```

src下面新建三个目录

> api：存放接口调用的js文件
>
> utils：存放工具js文件
>
> views：存放页面的.vue文件

```
api
utils
view
```

把request.js复制到utils

> request.js

```js
//定制请求的实例

//导入axios  npm install axios
import axios from 'axios';
//定义一个变量,记录公共的前缀  ,  baseURL
const baseURL = 'http://localhost:8080';
const instance = axios.create({baseURL})


//添加响应拦截器
instance.interceptors.response.use(
    result=>{
        return result.data;
    },
    err=>{
        alert('服务异常');
        return Promise.reject(err);//异步的状态转化成失败的状态
    }
)

export default instance;
```

## 复制资源文件

把下面的资源放到src/assets中

```
F:\file\JAVA技术学习\黑马Java_spring boot学习\02_资料\06_前端\12_大事件资料\01_静态资源assets
```

## 删除app.vue自动生成的内容

保留标签script、template、style，里面的内容清空

```vue
<script setup>

</script>

<template>
   
</template>

<style scoped>

</style>
```

# 注册

## 注册登录页面初始代码

```vue
<script setup>
import { User, Lock } from '@element-plus/icons-vue'
import { ref } from 'vue'
//控制注册与登录表单的显示， 默认显示注册
const isRegister = ref(false)
</script>

<template>
    <el-row class="login-page">
        <el-col :span="12" class="bg"></el-col>
        <el-col :span="6" :offset="3" class="form">
            <!-- 注册表单 -->
            <el-form ref="form" size="large" autocomplete="off" v-if="isRegister">
                <el-form-item>
                    <h1>注册</h1>
                </el-form-item>
                <el-form-item>
                    <el-input :prefix-icon="User" placeholder="请输入用户名"></el-input>
                </el-form-item>
                <el-form-item>
                    <el-input :prefix-icon="Lock" type="password" placeholder="请输入密码"></el-input>
                </el-form-item>
                <el-form-item>
                    <el-input :prefix-icon="Lock" type="password" placeholder="请输入再次密码"></el-input>
                </el-form-item>
                <!-- 注册按钮 -->
                <el-form-item>
                    <el-button class="button" type="primary" auto-insert-space>
                        注册
                    </el-button>
                </el-form-item>
                <el-form-item class="flex">
                    <el-link type="info" :underline="false" @click="isRegister = false">
                        ← 返回
                    </el-link>
                </el-form-item>
            </el-form>
            <!-- 登录表单 -->
            <el-form ref="form" size="large" autocomplete="off" v-else>
                <el-form-item>
                    <h1>登录</h1>
                </el-form-item>
                <el-form-item>
                    <el-input :prefix-icon="User" placeholder="请输入用户名"></el-input>
                </el-form-item>
                <el-form-item>
                    <el-input name="password" :prefix-icon="Lock" type="password" placeholder="请输入密码"></el-input>
                </el-form-item>
                <el-form-item class="flex">
                    <div class="flex">
                        <el-checkbox>记住我</el-checkbox>
                        <el-link type="primary" :underline="false">忘记密码？</el-link>
                    </div>
                </el-form-item>
                <!-- 登录按钮 -->
                <el-form-item>
                    <el-button class="button" type="primary" auto-insert-space>登录</el-button>
                </el-form-item>
                <el-form-item class="flex">
                    <el-link type="info" :underline="false" @click="isRegister = true">
                        注册 →
                    </el-link>
                </el-form-item>
            </el-form>
        </el-col>
    </el-row>
</template>

<style lang="scss" scoped>
/* 样式 */
.login-page {
    height: 100vh;
    background-color: #fff;

    .bg {
        background: url('@/assets/logo2.png') no-repeat 60% center / 240px auto,
            url('@/assets/login_bg.jpg') no-repeat center / cover;
        border-radius: 0 20px 20px 0;
    }

    .form {
        display: flex;
        flex-direction: column;
        justify-content: center;
        user-select: none;

        .title {
            margin: 0 auto;
        }

        .button {
            width: 100%;
        }

        .flex {
            width: 100%;
            display: flex;
            justify-content: space-between;
        }
    }
}
</style>
```

## 注册的数据模型

在script标签中加入注册的数据模型，用于注册和登录的数据绑定

```js
//用于注册的数据模型
const registerData = ref({
    username: '',
    password: '',
    rePassword: ''
})
```

### 在注册表单中绑定数据模型

```vue
            <el-form ref="form" size="large" autocomplete="off" v-if="isRegister" :model="registerData">
```

### 在输入框中绑定数据模型

```vue
v-model="registerData.username"
v-model="registerData.password"
v-model="registerData.rePassword"
```

## 表单校验

### 定义校验逻辑

下面代码是官方的密码校验和字段校验逻辑，直接用就好了

```js
//自定义确认密码的校验函数
const rePasswordValid = (rule, value, callback) => {
    if (value == null || value === '') {
         callback(new Error('请再次确认密码'))
    }
    if ( value !== registerData.value.password ) {
         callback(new Error('输入密码不一致'))
    }else{
        callback() 
    }

}
//定义表单校验规则
const rules = {
    username: [
        { required: true, message: '请输入用户名', trigger: 'blur' },
        { min: 3, max: 16, message: '长度在 3 到 16 个字符', trigger: 'blur' }
    ], 
    password: [
        { required: true, message: '请输入密码', trigger: 'blur' },
        { min: 6, max: 12, message: '长度在 6 到 12 个字符', trigger: 'blur' } 
    ],
    rePassword: [
        { validator: rePasswordValid, trigger: 'blur' }

    ]
}
```

### 表单校验绑定

在注册表单中绑定数据模型 :rules="rules"

```vue
 :rules="rules"
```

绑定规则

```vue
prop ="username"
prop ="password"
prop ="rePassword"
```

##  接口调用

### 事件绑定

给按钮绑定点击事件

```
@click ="register"
```

### 编写调用接口

在user.js中编写注册调用函数

> 因为是urlencoded表单格式，需要URLSearchParams，把它转为格式为 `key1=value1&key2=value2`这种格式

```js
export const userRegisterService = (registerData) => {
    //借助urlsearchparams 把对象转换为url编码的格式
    const params = new URLSearchParams();
    for (const key in registerData) {
        params.append(key, registerData[key])
    }
    return request.post('/user/register', params);

}
```



### 编写函数

```js
//注册函数
import {userRegisterService} from "@/api/user.js"
const register =  async () => {
   let result = await userRegisterService(registerData.value);
   ElMessage.success('注册成功');
}
```

## 处理CORS

修改vite.config.js

在defineConfig添加

不依靠浏览器从5173发起8080，而是依靠前端服务器发起8080，避免跨域问题

```js
server: {
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      }
    }
  }
```

# 登录

## 登录数据模型

```
复用注册的数据模型
```

### 绑定数据模型

```
v-model="registerData.username"
v-model="registerData.password"
v-model="registerData.rePassword"
```



## 表单校验

### 定义校验逻辑

```
复用注册的校验逻辑
```

### 表单校验绑定

在注册表单中绑定数据模型 :rules="rules"

```vue
 :rules="rules"
```

绑定规则

```
prop ="username"
prop ="password"
```

## 接口调用

给按钮绑定点击事件

```
@click ="login"
```

### 编写调用接口

```js
export const userLoginService = (loginData) => {
    const params = new URLSearchParams();
    for (const key in loginData) {
        params.append(key, loginData[key])
   
     } 
     return request.post('/user/login', params);
}
```

## 编写函数

```js
const login =  async () => {
    let result = await userLoginService(registerData.value);
    ElMessage.success('登录成功');
}
```

## 优化

### 回车键实现登录

登录菜单上添加 @keyup.enter 事件处理，当用户在表单中按下回车键时触发登录操作。

 ```vue
 <el-form ref="form" size="large" autocomplete="off" v-else :model="registerData" :rules="rules" @keyup.enter="handleEnterLogin">
 ```

添加处理函数

```js
// 添加回车键登录处理函数
const handleEnterLogin = () => {
    //判断如果是登录变量，执行登录
  if (!isRegister.value) {
    login()
  }
}
```

### 记住我

导入了 onMounted 钩子函数，用于页面加载时检查本地存储

```js
import { ref, onMounted } from 'vue'
```

添加了 rememberMe 响应式变量，用于跟踪"记住我"复选框的状态

```js
// 添加记住我状态
const rememberMe = ref(false)
```

修改了登录函数 login ，添加了处理"记住我"功能的逻辑：
- 勾选时，将用户名和密码存储到 localStorage
- 未勾选时，清除 localStorage 中的信息

```js
const login = async () => {
    let result = await userLoginService(registerData.value);
    // 保存token
    tokenStore.setToken(result.data)
    
    // 处理记住我功能
    if (rememberMe.value) {
        // 如果勾选了记住我，将用户信息存储到本地
        localStorage.setItem('loginInfo', JSON.stringify({
            username: registerData.value.username,
            password: registerData.value.password
        }))
    } else {
        // 如果没有勾选记住我，清除本地存储
        localStorage.removeItem('loginInfo')
    }
    
    ElMessage.success('登录成功');
    // 登录成功后，跳转到首页
    router.push('/')
}
```

添加了 onMounted 钩子函数，在页面加载时检查是否有存储的登录信息，如果有则自动填充

```js
// 页面加载时检查是否有存储的登录信息
onMounted(() => {
    const loginInfo = localStorage.getItem('loginInfo')
    if (loginInfo) {
        const { username, password } = JSON.parse(loginInfo)
        registerData.value.username = username
        registerData.value.password = password
        rememberMe.value = true
    }
})
```

将复选框与 rememberMe 变量绑定，使用 v-model="rememberMe"

```vue
 <el-checkbox v-model="rememberMe">记住我</el-checkbox>
```



# 主页面搭建

## 创建Layout.vue

> 在view中创建Layout.vue

```vue
<script setup>
import {
    Management,
    Promotion,
    UserFilled,
    User,
    Crop,
    EditPen,
    SwitchButton,
    CaretBottom
} from '@element-plus/icons-vue'
import avatar from '@/assets/default.png'
</script>

<template>
    <el-container class="layout-container">
        <!-- 左侧菜单 -->
        <el-aside width="200px">
            <div class="el-aside__logo"></div>
            <el-menu active-text-color="#ffd04b" background-color="#232323"  text-color="#fff"
                router>
                <el-menu-item >
                    <el-icon>
                        <Management />
                    </el-icon>
                    <span>文章分类</span>
                </el-menu-item>
                <el-menu-item >
                    <el-icon>
                        <Promotion />
                    </el-icon>
                    <span>文章管理</span>
                </el-menu-item>
                <el-sub-menu >
                    <template #title>
                        <el-icon>
                            <UserFilled />
                        </el-icon>
                        <span>个人中心</span>
                    </template>
                    <el-menu-item >
                        <el-icon>
                            <User />
                        </el-icon>
                        <span>基本资料</span>
                    </el-menu-item>
                    <el-menu-item >
                        <el-icon>
                            <Crop />
                        </el-icon>
                        <span>更换头像</span>
                    </el-menu-item>
                    <el-menu-item >
                        <el-icon>
                            <EditPen />
                        </el-icon>
                        <span>重置密码</span>
                    </el-menu-item>
                </el-sub-menu>
            </el-menu>
        </el-aside>
        <!-- 右侧主区域 -->
        <el-container>
            <!-- 头部区域 -->
            <el-header>
                <div>黑马程序员：<strong>东哥</strong></div>
                <el-dropdown placement="bottom-end">
                    <span class="el-dropdown__box">
                        <el-avatar :src="avatar" />
                        <el-icon>
                            <CaretBottom />
                        </el-icon>
                    </span>
                    <template #dropdown>
                        <el-dropdown-menu>
                            <el-dropdown-item command="profile" :icon="User">基本资料</el-dropdown-item>
                            <el-dropdown-item command="avatar" :icon="Crop">更换头像</el-dropdown-item>
                            <el-dropdown-item command="password" :icon="EditPen">重置密码</el-dropdown-item>
                            <el-dropdown-item command="logout" :icon="SwitchButton">退出登录</el-dropdown-item>
                        </el-dropdown-menu>
                    </template>
                </el-dropdown>
            </el-header>
            <!-- 中间区域 -->
            <el-main>
                <div style="width: 1290px; height: 570px;border: 1px solid red;">
                    内容展示区
                </div>
            </el-main>
            <!-- 底部区域 -->
            <el-footer>大事件 ©2023 Created by 黑马程序员</el-footer>
        </el-container>
    </el-container>
</template>

<style lang="scss" scoped>
.layout-container {
    height: 100vh;

    .el-aside {
        background-color: #232323;

        &__logo {
            height: 120px;
            background: url('@/assets/logo.png') no-repeat center / 120px auto;
        }

        .el-menu {
            border-right: none;
        }
    }

    .el-header {
        background-color: #fff;
        display: flex;
        align-items: center;
        justify-content: space-between;

        .el-dropdown__box {
            display: flex;
            align-items: center;

            .el-icon {
                color: #999;
                margin-left: 10px;
            }

            &:active,
            &:focus {
                outline: none;
            }
        }
    }

    .el-footer {
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        color: #666;
    }
}
</style>
```

## 引入

> 在App.vue中引入Layout.vue

```vue
<script setup>
    import LoginVue from '@/views/Login.vue'
    import LayoutVue from '@/views/Layout.vue'
</script>

<template>
    <!-- <LoginVue /> -->
    <LayoutVue />
</template>

<style scoped>

</style>

```

## 路由

### 安装路由依赖

```shell
npm install vue-router@4
```

### 创建路由，导出

> 在src/router目录下，定义一个js文件，起名为index.js

```js
//导入vue-router
import { createRouter, createWebHistory } from 'vue-router'
//导入组件
import LoginVue from '@/views/Login.vue'
import LayoutVue from '@/views/Layout.vue'

//定义路由关系
const routes = [
    { path: '/login', component: LoginVue },
    { path: '/', component: LayoutVue }
]

//创建路由器
const router = createRouter({
    history: createWebHistory(),
    routes: routes
});

export default router
```

### 使用router

> 在main.js中导入

```js
import router from '@/router/index.js'

app.use(router)
```

### 声明router-view标签，展示组件内容

> 在App.vue中声明标签

```vue
<template>
   <router-view></router-view>
</template>
```

### 登录成功页面跳转

> 导入获取路由器
>
> 使用router.push('/')来进行页面的跳转

```js
import { useRouter } from 'vue-router'
const router = useRouter();

const login =  async () => {
    let result = await userLoginService(registerData.value);
    ElMessage.success('登录成功');
    //登录成功后，跳转到首页
    router.push('/')
}
```

## 子路由

### 复制资料路由

> - ArticleCategory.vue
> - ArticleManage.vue
> - UserInfo.vue
> - UserAvatar.vue
> - UserResetPassword.vue
>
> 把两个文件夹放到src/views目录下

```
F:\file\JAVA技术学习\黑马Java_spring boot学习\02_资料\06_前端\12_大事件资料\03_vue文件
```

### 配置子路由

> index.js中，把vue导入，在  '/' 路径下面的LayoutVue下注册子路由

```js
//导入vue-router
import { createRouter, createWebHistory } from 'vue-router'
//导入组件
import LoginVue from '@/views/Login.vue'
import LayoutVue from '@/views/Layout.vue'
import ArticleCategoryVue from '@/views/article/ArticleCategory.vue'
import ArticleManageVue from '@/views/article/ArticleManage.vue'
import UserInfoVue from '@/views/user/UserInfo.vue'
import UserAvatarVUe from '@/views/user/UserAvatar.vue'
import UserResetPasswordVue from '@/views/user/UserResetPassword.vue'
//定义路由关系
const routes = [
    { path: '/login', component: LoginVue },
    { path: '/', component: LayoutVue,children: [
        { path: '/category/list', component: ArticleCategoryVue },
        { path: '/article/manage', component: ArticleManageVue },
        { path: '/user/info', component: UserInfoVue },
        { path: '/user/avatar', component: UserAvatarVUe },
        { path: '/user/password', component: UserResetPasswordVue }
    ] }
]

//创建路由器
const router = createRouter({
    history: createWebHistory(),
    routes: routes
});

export default router
```



### 声明router-view标签

> 在Layout.vue中使用<router-view />声明

```vue
<el-main>
                <!-- <div style="width: 1290px; height: 570px;border: 1px solid red;">
                    内容展示区
                </div> -->
                <router-view />
            </el-main>
```

### 设置index属性

> 在Layout.vue中，给每个点击项设置index属性
>
> 组个配置：
>
> - index='/category/list'
> - index='/article/manage'
> - index='/user/info'
> - index='/user/avatar'
> - index='/user/password'

 ```vue
 <el-menu-item index='/article/category'>
     <el-icon>
         <Management />
     </el-icon>
     <span>文章分类</span>
 </el-menu-item>
 ```

### 默认组件展示，重定向

> http://localhost:5173/ 访问的时候是空白，需要默认展示，
>
> //重定向
>         redirect: '/article/manage',

```js
//定义路由关系
const routes = [
    { path: '/login', component: LoginVue },
    {
        path: '/',
        component: LayoutVue,
        //重定向
        redirect: '/article/manage',
        //子路由
        children: [
            { path: '/category/list', component: ArticleCategoryVue },
            { path: '/article/manage', component: ArticleManageVue },
            { path: '/user/info', component: UserInfoVue },
            { path: '/user/avatar', component: UserAvatarVUe },
            { path: '/user/password', component: UserResetPasswordVue },
        ]
    }
]
```



# 文章分类

## 文章分类列表

### 粘贴代码

> 粘贴下面的到ArticleCategory.vue

```vue
<script setup>
import {
    Edit,
    Delete
} from '@element-plus/icons-vue'
import { ref } from 'vue'
const categorys = ref([
    {
        "id": 3,
        "categoryName": "美食",
        "categoryAlias": "my",
        "createTime": "2023-09-02 12:06:59",
        "updateTime": "2023-09-02 12:06:59"
    },
    {
        "id": 4,
        "categoryName": "娱乐",
        "categoryAlias": "yl",
        "createTime": "2023-09-02 12:08:16",
        "updateTime": "2023-09-02 12:08:16"
    },
    {
        "id": 5,
        "categoryName": "军事",
        "categoryAlias": "js",
        "createTime": "2023-09-02 12:08:33",
        "updateTime": "2023-09-02 12:08:33"
    }
])
</script>
<template>
    <el-card class="page-container">
        <template #header>
            <div class="header">
                <span>文章分类</span>
                <div class="extra">
                    <el-button type="primary">添加分类</el-button>
                </div>
            </div>
        </template>
        <el-table :data="categorys" style="width: 100%">
            <el-table-column label="序号" width="100" type="index"> </el-table-column>
            <el-table-column label="分类名称" prop="categoryName"></el-table-column>
            <el-table-column label="分类别名" prop="categoryAlias"></el-table-column>
            <el-table-column label="操作" width="100">
                <template #default="{ row }">
                    <el-button :icon="Edit" circle plain type="primary" ></el-button>
                    <el-button :icon="Delete" circle plain type="danger"></el-button>
                </template>
            </el-table-column>
            <template #empty>
                <el-empty description="没有数据" />
            </template>
        </el-table>
    </el-card>
</template>

<style lang="scss" scoped>
.page-container {
    min-height: 100%;
    box-sizing: border-box;

    .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
}
</style>
```

### 接口调用

> 新建src/api/article.js

```js
//导入请求工具类
import request from '@/utils/request.js'

//文章分类列表查询
export const articleCategoryListService = ()=>{
    return request.get('/category')
}
```

### 调用函数

> ArticleCategory.vue

```js
//获取所有文章分类数据
import { articleCategoryListService } from '@/api/article.js'
const getAllCategory = async () => {
    let result = await articleCategoryListService();
    categorys.value = result.data;
}
getAllCategory();
```

### token持久化

> 绑定token

#### 安装

```shell
npm install pinia
```

#### 使用Pinia

>  在main.js中引入

```js
import { createPinia } from 'pinia'

const pinia = createPinia()
app.use(pinia)
```

#### 定义Store

> 在src/stores目录下定义token.js
>
> 在里面定义函数defineStore，通过唯一标识符token,给它指定两个方法
>
> setToken、removeToken

```js
import { defineStore } from "pinia";
import {ref} from 'vue';

/*
    defineStore参数描述：
        第一个参数：给状态起名，具有唯一性
        第二个参数：函数，可以把定义该状态中拥有的内容

    defineStore返回值描述：
        返回的是一个函数，将来可以调用该函数，得到第二个参数中返回的内容
*/
export const useTokenStore = defineStore('token',()=>{
    //1.定义描述token
    const token = ref('')

    //2.定义修改token的方法
    const setToken = (newToken)=>{
        token.value = newToken
    }

    //3.定义移除token的方法
    const removeToken = ()=>{
        token.value=''
    }
    return {
        token,setToken,removeToken
    }
})
```

####  存储token

> 在login.vue把token存进去
>
> - 导入token状态
> - 调用useTokenStore得到状态
> -   保存token

```js
//导入token状态
import { useTokenStore } from '@/stores/token.js'

//调用useTokenStore得到状态
const tokenStore = useTokenStore();

//用于登录的事件函数
const login = async () => {
    let result = await loginService(registerData.value)
    //保存token
    tokenStore.setToken(result.data)
    
    ElMessage.success('登录成功!')
    router.push('/')
}
```
#### 使用token

> 在article.js中，给请求接口统一在请求头中携带token

```js
//导入@/stores/token.js
import { useTokenStore } from '../stores/token'


//文章分类列表查询
export const articleCategoryListService = () => {
    //获取token状态
    const tokenStore = useTokenStore()
    //通过请求头Authorization携带token
    return request.get('/category', { headers: { 'Authorization': tokenStore.token } })
}
```

#### axios请求拦截器

> 当进入主页后，将来要与后台交互，都需要携带token，如果每次请求都写这样的代码，将会比较繁琐，此时可以将携带token的代码通过请求拦截器统一处理
>
> 在 src/util/request.js中

```js
//导入token状态
import { useTokenStore } from '@/stores/token.js';
//添加请求拦截器
instance.interceptors.request.use(
    (config)=>{
        //在发送请求之前做什么
        let tokenStore = useTokenStore()
        //如果token中有值，在携带
        if(tokenStore.token){
            config.headers.Authorization=tokenStore.token
        }
        return config
    },
    (err)=>{
        //如果请求错误做什么
        Promise.reject(err)
    }
)
```

#### pinia持久化

> 默认情况下，由于pinia是内存存储，当你刷新页面的时候pinia中的数据会丢失，可以借助于persist插件解决这个问题，persist插件支持将pinia中的数据持久化到sessionStorage和localStorage中

##### 安装插件

```shell
npm install pinia-persistedstate-plugin
```

##### pinia中使用persist插件

> 在main.js中

```js
import { createPinia } from 'pinia'
//导入持久化插件
import {createPersistedState} from'pinia-persistedstate-plugin'
const pinia = createPinia()
const persist = createPersistedState()
//pinia使用持久化插件
pinia.use(persist)
app.use(pinia)
```

##### 在创建定义状态是配置持久化

> 在src/stores/token.js中

```js
export const useTokenStore = defineStore('token',()=>{
    //1.定义描述token
    const token = ref('')

    //2.定义修改token的方法
    const setToken = (newToken)=>{
        token.value = newToken
    }

    //3.定义移除token的方法
    const removeToken = ()=>{
        token.value=''
    }
    return {
        token,setToken,removeToken
    }
}
,
//参数持久化
{
    persist:true
}
)
```

#### 未登录统一处理

> 在后续访问接口时，如果没有登录，则前端不携带token，后台服务器会返回响应状态码401，代表未登录，此时可以在axios的响应拦截器中，统一对未登录的情况做处理
>
> request.js

```js
import router from '@/router'


//添加响应拦截器
instance.interceptors.response.use(
    result=>{
        //如果业务状态码为0，代表本次操作成功
        if (result.data.code == 0) {
            return result.data;
        }
        //业务状态码不为0，代表操作失败
        ElMessage.error(result.data.message?result.data.message : '服务异常');
        return Promise.reject(result.data);
    },
    err => {
        //如果响应状态码时401，代表未登录，给出对应的提示，并跳转到登录页
        if(err.response.status===401){
            ElMessage.error('请先登录！')
            router.push('/login')
        }else{
            ElMessage.error('服务异常');
        }
        return Promise.reject(err);//异步的状态转化成失败的状态
    }
)
```



## 新增文章分类

### 添加分类弹窗页面

> 复制下面代码到ArticleCategory.vue中

```vue
<!-- 添加分类弹窗 -->
<el-dialog v-model="dialogVisible" title="添加弹层" width="30%">
    <el-form :model="categoryModel" :rules="rules" label-width="100px" style="padding-right: 30px">
        <el-form-item label="分类名称" prop="categoryName">
            <el-input v-model="categoryModel.categoryName" minlength="1" maxlength="10"></el-input>
        </el-form-item>
        <el-form-item label="分类别名" prop="categoryAlias">
            <el-input v-model="categoryModel.categoryAlias" minlength="1" maxlength="15"></el-input>
        </el-form-item>
    </el-form>
    <template #footer>
        <span class="dialog-footer">
            <el-button @click="dialogVisible = false">取消</el-button>
            <el-button type="primary"> 确认 </el-button>
        </span>
    </template>
</el-dialog>
```

### 添加分类弹窗

> ArticleCategory.vue的script中

```js
//控制添加分类弹窗
const dialogVisible = ref(false);
```

### 添加分类表单数据

> ArticleCategory.vue的script中

```js
//添加分类表单数据
const categoryModel = ref({
    categoryName: '',
    categoryAlias: ''
})
```

### 表单校验规则

> ArticleCategory.vue的script中

```js
//表单校验规则
const rules = ref({
    categoryName: [{ required: true, message: '请输入分类名称', trigger: 'blur' }],
    categoryAlias: [{ required: true, message: '请输入分类别名', trigger: 'blur' }]  
})
```

### 添加分类按钮单击事件

> 点击之后弹窗，改成true

```vue
 <el-button type="primary" @click="dialogVisible = true">添加分类</el-button>
```

### 添加接口

> 在article.js中添加新增接口

```js
//添加文章分类
export const articleCategoryAddService = (categoryModel) => {
    return request.post('/category', categoryModel)
}
```

### 调用接口

> 在ArticleCategory.vue中调用
>
> - 访问接口
> - 隐藏弹窗
> - 刷新页面

```js

import { ElMessage } from 'element-plus'
const addCategory = async ()=>{
    let result = await articleCategoryAddService(categoryModel.value);
    ElMessage.success('添加成功')
    //隐藏弹窗
    dialogVisible.value = false
    //再次访问后台接口，查询所有分类
    getAllCategory()
}
```

### 绑定按钮事件

```vue
<el-button type="primary" @click="addCategory"> 确认 </el-button>
```

## 更新文章分类

### 弹窗显示

> 在ArticleCategory.vue中初始化一个标题属性

```js
//弹窗标题
const title=ref('')
```

### 在弹窗上绑定标题

> 每次对话框中的标题都从属性中获取

```vue
 <el-dialog v-model="dialogVisible" :title="title" width="30%">
```

### 数据回显

> 当点击修改按钮的时候，需要把详细信息回显到框中，通过插槽的方式得到被点击按钮所在行的数据，row代表是行数

```vue
 <el-table-column label="操作" width="100">
                <template #default="{ row }">
                    <el-button :icon="Edit" circle plain type="primary" @click="title='修改文章';dialogVisible=true"></el-button>
                    <el-button :icon="Delete" circle plain type="danger" @click="deleteArticle(row)"></el-button>
                </template>
            </el-table-column>
```

### 回显函数

> 把之前的属性放在了一起，在这个函数中

```js
//修改分类回显
const updateCategoryEcho = (row) => {
    title.value = '修改分类'
    dialogVisible.value = true
    //将row中的数据赋值给categoryModel
    categoryModel.value.categoryName=row.categoryName
    categoryModel.value.categoryAlias=row.categoryAlias
    //修改的时候必须传递分类的id，所以扩展一个id属性
    categoryModel.value.id=row.id
}
```

### 引入接口

> 在category.js中提供修改分类的函数

```js
//修改分类
export const articleCategoryUpdateService = (categoryModel)=>{
    return request.put('/category',categoryModel)
}
```

### 修改确定按钮的绑定事件

> 复用对话框的确认
>
> 如果是添加分类，就调用添加函数addCategory()
>
> 如果是编辑分类就调用编辑函数updateCategory()

```vue
 <span class="dialog-footer">
                <el-button @click="dialogVisible = false">取消</el-button>
                <el-button type="primary" @click="title==='添加分类'? addCategory():updateCategory()"> 确认 </el-button>
            </span>
```

### 调用接口完成修改的函数

```js
//修改分类
import { articleCategoryUpdateService } from '@/api/category.js'
const updateCategory=async ()=>{
    let result = await articleCategoryUpdateService(categoryModel.value)
    ElMessage.success('修改成功')
    //隐藏弹窗
    dialogVisible.value=false
    //再次访问后台接口，查询所有分类
    getAllCategory()
}
```

### 修改和新增共用数据模型兼容

> 添加分类，并不希望回显数据，使用函数清空

```js
//清空模型数据
const clearCategoryModel = ()=>{
    categoryModel.value.categoryName='',
    categoryModel.value.categoryAlias=''
}
```

> 调用

```vue
<el-button type="primary" @click="title='添加分类';dialogVisible = true;clearCategoryModel()">添加分类</el-button>
```

## 删除文章分类

### 对话框弹框

```js
import { ElMessageBox } from 'element-plus'
import { articleCategoryDeleteService } from '@/api/article.js'
//删除分类
const deleteCategory = (row) => {
    ElMessageBox.confirm(
        '你确认删除该分类信息吗？',
        '温馨提示',
        {
            confirmButtonText: '确认',
            cancelButtonText: '取消',
            type: 'warning',
        }
    )
        .then(async () => {
            //用户点击了确认
            let result = await articleCategoryDeleteService(row.id)
            ElMessage.success(result.message?result.message:'删除成功')
            //再次调用getAllCategory，获取所有文章分类
            getAllCategory()
        })
        .catch(() => {
            //用户点击了取消
            ElMessage({
                type: 'info',
                message: '取消删除',
            })
        })
}
```

### 接口调用

> article.js中提供删除分类的函数

```js
//删除分类
export const articleCategoryDeleteService = (id) => {
    return request.delete('/category?id='+id)
}
```

# 文章

## 文章列表条件分页

### 文章vue代码

> 复制下面的代码到ArticleManage.vue

```vue
<script setup>
import {
    Edit,
    Delete
} from '@element-plus/icons-vue'

import { ref } from 'vue'

//文章分类数据模型
const categorys = ref([
    {
        "id": 3,
        "categoryName": "美食",
        "categoryAlias": "my",
        "createTime": "2023-09-02 12:06:59",
        "updateTime": "2023-09-02 12:06:59"
    },
    {
        "id": 4,
        "categoryName": "娱乐",
        "categoryAlias": "yl",
        "createTime": "2023-09-02 12:08:16",
        "updateTime": "2023-09-02 12:08:16"
    },
    {
        "id": 5,
        "categoryName": "军事",
        "categoryAlias": "js",
        "createTime": "2023-09-02 12:08:33",
        "updateTime": "2023-09-02 12:08:33"
    }
])

//用户搜索时选中的分类id
const categoryId=ref('')

//用户搜索时选中的发布状态
const state=ref('')

//文章列表数据模型
const articles = ref([
    {
        "id": 5,
        "title": "陕西旅游攻略",
        "content": "兵马俑,华清池,法门寺,华山...爱去哪去哪...",
        "coverImg": "https://big-event-gwd.oss-cn-beijing.aliyuncs.com/9bf1cf5b-1420-4c1b-91ad-e0f4631cbed4.png",
        "state": "草稿",
        "categoryId": 2,
        "createTime": "2023-09-03 11:55:30",
        "updateTime": "2023-09-03 11:55:30"
    },
    {
        "id": 5,
        "title": "陕西旅游攻略",
        "content": "兵马俑,华清池,法门寺,华山...爱去哪去哪...",
        "coverImg": "https://big-event-gwd.oss-cn-beijing.aliyuncs.com/9bf1cf5b-1420-4c1b-91ad-e0f4631cbed4.png",
        "state": "草稿",
        "categoryId": 2,
        "createTime": "2023-09-03 11:55:30",
        "updateTime": "2023-09-03 11:55:30"
    },
    {
        "id": 5,
        "title": "陕西旅游攻略",
        "content": "兵马俑,华清池,法门寺,华山...爱去哪去哪...",
        "coverImg": "https://big-event-gwd.oss-cn-beijing.aliyuncs.com/9bf1cf5b-1420-4c1b-91ad-e0f4631cbed4.png",
        "state": "草稿",
        "categoryId": 2,
        "createTime": "2023-09-03 11:55:30",
        "updateTime": "2023-09-03 11:55:30"
    },
])

//分页条数据模型
const pageNum = ref(1)//当前页
const total = ref(20)//总条数
const pageSize = ref(3)//每页条数

//当每页条数发生了变化，调用此函数
const onSizeChange = (size) => {
    pageSize.value = size
}
//当前页码发生变化，调用此函数
const onCurrentChange = (num) => {
    pageNum.value = num
}
</script>
<template>
    <el-card class="page-container">
        <template #header>
            <div class="header">
                <span>文章管理</span>
                <div class="extra">
                    <el-button type="primary">添加文章</el-button>
                </div>
            </div>
        </template>
        <!-- 搜索表单 -->
        <el-form inline>
            <el-form-item label="文章分类：">
                <el-select placeholder="请选择" v-model="categoryId">
                    <el-option 
                        v-for="c in categorys" 
                        :key="c.id" 
                        :label="c.categoryName"
                        :value="c.id">
                    </el-option>
                </el-select>
            </el-form-item>

            <el-form-item label="发布状态：">
                <el-select placeholder="请选择" v-model="state">
                    <el-option label="已发布" value="已发布"></el-option>
                    <el-option label="草稿" value="草稿"></el-option>
                </el-select>
            </el-form-item>
            <el-form-item>
                <el-button type="primary">搜索</el-button>
                <el-button>重置</el-button>
            </el-form-item>
        </el-form>
        <!-- 文章列表 -->
        <el-table :data="articles" style="width: 100%">
            <el-table-column label="文章标题" width="400" prop="title"></el-table-column>
            <el-table-column label="分类" prop="categoryId"></el-table-column>
            <el-table-column label="发表时间" prop="createTime"> </el-table-column>
            <el-table-column label="状态" prop="state"></el-table-column>
            <el-table-column label="操作" width="100">
                <template #default="{ row }">
                    <el-button :icon="Edit" circle plain type="primary"></el-button>
                    <el-button :icon="Delete" circle plain type="danger"></el-button>
                </template>
            </el-table-column>
            <template #empty>
                <el-empty description="没有数据" />
            </template>
        </el-table>
        <!-- 分页条 -->
        <el-pagination v-model:current-page="pageNum" v-model:page-size="pageSize" :page-sizes="[3, 5 ,10, 15]"
            layout="jumper, total, sizes, prev, pager, next" background :total="total" @size-change="onSizeChange"
            @current-change="onCurrentChange" style="margin-top: 20px; justify-content: flex-end" />
    </el-card>
</template>
<style lang="scss" scoped>
.page-container {
    min-height: 100%;
    box-sizing: border-box;

    .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
}
</style>
```

### 导入中文包

> 分页栏显示是英文，需要修改为中文显示，在main.js中引入

```js
import locale from 'element-plus/dist/locale/zh-cn.js'

app.use(ElementPlus,{locale})

//把之前的app.use(ElementPlus) 去掉
```

### 接口调用

> article.js中提供获取文章列表数据的函数(将category.js和article.js分开了)

```js
//文章列表查询
export const articleListService = (params) => {
    return request.get('/article', { params: params })
}
```

### 调用接口获取数据

> 在articleManage.vue中添加

```js
//文章列表查询
import { articleListService } from '@/api/article.js'
const getArticles = async () => {
    let params = {
        pageNum: pageNum.value,
        pageSize: pageSize.value,
        categoryId: categoryId.value ? categoryId.value : null,
        state: state.value ? state.value : null
    }
    let result = await articleListService(params);
    //渲染列表数据
    articles.value = result.data.items
    //为列表中添加categoryName属性
    for(let i=0;i<articles.value.length;i++){
        let article = articles.value[i];
        for(let j=0;j<categorys.value.length;j++){
            if(article.categoryId===categorys.value[j].id){
                article.categoryName=categorys.value[j].categoryName
            }
        }
    }
    //渲染总条数
    total.value=result.data.total
}
getArticles()
```

### 绑定分类列

> 把prop="categoryId" 改成 prop="categoryName"

```vue
<el-table-column label="分类" prop="categoryName"></el-table-column>
```

### 每页条数

```js
//当每页条数发生了变化，调用此函数
const onSizeChange = (size) => {
    pageSize.value = size
    getArticles()
}
```

###  当前页码

```js
//当前页码发生变化，调用此函数
const onCurrentChange = (num) => {
    pageNum.value = num
    getArticles()
}
```

## 搜索和重置

### 搜索按钮绑定

```vue
<el-button type="primary" @click="getArticles">搜索</el-button>
```

### 重置按钮绑定

```vue
 <el-button @click="categoryId='';state=''">重置</el-button>
```

## 添加文章

### 数据模型

```js
import {Plus} from '@element-plus/icons-vue'
//控制抽屉是否显示
const visibleDrawer = ref(false)
//添加表单数据模型
const articleModel = ref({
    title: '',
    categoryId: '',
    coverImg: '',
    content:'',
    state:''
})
```

### 抽屉

```html
<!-- 抽屉 -->
        <el-drawer v-model="visibleDrawer" title="添加文章" direction="rtl" size="50%">
            <!-- 添加文章表单 -->
            <el-form :model="articleModel" label-width="100px" >
                <el-form-item label="文章标题" >
                    <el-input v-model="articleModel.title" placeholder="请输入标题"></el-input>
                </el-form-item>
                <el-form-item label="文章分类">
                    <el-select placeholder="请选择" v-model="articleModel.categoryId">
                        <el-option v-for="c in categorys" :key="c.id" :label="c.categoryName" :value="c.id">
                        </el-option>
                    </el-select>
                </el-form-item>
                <el-form-item label="文章封面">

                    <el-upload class="avatar-uploader" :auto-upload="false" :show-file-list="false">
                        <img v-if="articleModel.coverImg" :src="articleModel.coverImg" class="avatar" />
                        <el-icon v-else class="avatar-uploader-icon">
                            <Plus />
                        </el-icon>
                    </el-upload>
                </el-form-item>
                <el-form-item label="文章内容">
                    <div class="editor">富文本编辑器</div>
                </el-form-item>
                <el-form-item>
                    <el-button type="primary">发布</el-button>
                    <el-button type="info">草稿</el-button>
                </el-form-item>
            </el-form>
        </el-drawer>
```

### 抽屉组件

```vue
<!-- 抽屉 -->
        <el-drawer v-model="visibleDrawer" title="添加文章" direction="rtl" size="50%">
            <!-- 添加文章表单 -->
            <el-form :model="articleModel" label-width="100px" >
                <el-form-item label="文章标题" >
                    <el-input v-model="articleModel.title" placeholder="请输入标题"></el-input>
                </el-form-item>
                <el-form-item label="文章分类">
                    <el-select placeholder="请选择" v-model="articleModel.categoryId">
                        <el-option v-for="c in categorys" :key="c.id" :label="c.categoryName" :value="c.id">
                        </el-option>
                    </el-select>
                </el-form-item>
                <el-form-item label="文章封面">

                    <el-upload class="avatar-uploader" :auto-upload="false" :show-file-list="false">
                        <img v-if="articleModel.coverImg" :src="articleModel.coverImg" class="avatar" />
                        <el-icon v-else class="avatar-uploader-icon">
                            <Plus />
                        </el-icon>
                    </el-upload>
                </el-form-item>
                <el-form-item label="文章内容">
                    <div class="editor">富文本编辑器</div>
                </el-form-item>
                <el-form-item>
                    <el-button type="primary">发布</el-button>
                    <el-button type="info">草稿</el-button>
                </el-form-item>
            </el-form>
        </el-drawer>
```

### 抽屉CSS样式

```css
/* 抽屉样式 */
.avatar-uploader {
    :deep() {
        .avatar {
            width: 178px;
            height: 178px;
            display: block;
        }

        .el-upload {
            border: 1px dashed var(--el-border-color);
            border-radius: 6px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: var(--el-transition-duration-fast);
        }

        .el-upload:hover {
            border-color: var(--el-color-primary);
        }

        .el-icon.avatar-uploader-icon {
            font-size: 28px;
            color: #8c939d;
            width: 178px;
            height: 178px;
            text-align: center;
        }
    }
}
.editor {
  width: 100%;
  :deep(.ql-editor) {
    min-height: 200px;
  }
}
```

### 添加文章按钮绑定事件

```vue
<el-button type="primary" @click="visibleDrawer = true">添加文章</el-button>
```

### 富文本编辑器

> 文章内容需要使用到富文本编辑器，这里咱们使用一个开源的富文本编辑器 Quill
>
> 官网地址： https://vueup.github.io/vue-quill/

#### 安装

```
npm install @vueup/vue-quill@latest --save
```

#### 导入组件和样式

```js
import { QuillEditor } from '@vueup/vue-quill'
import '@vueup/vue-quill/dist/vue-quill.snow.css'
```

#### 页面长使用quill组件：

> 把下面的内容替换富文本编辑器

```vue
<quill-editor
              theme="snow"
              v-model:content="articleModel.content"
              contentType="html"
              >
</quill-editor>
```

#### 样式美化（上面已添加）

```css
.editor {
  width: 100%;
  :deep(.ql-editor) {
    min-height: 200px;
  }
}
```

### 文章封面图片

> 将来当点击+图标，选择本地图片后，el-upload这个组件会自动发送请求，把图片上传到指定的服务器上，而不需要我们自己使用axios发送异步请求，所以需要给el-upload标签添加一些属性，控制请求的发送
>
> auto-upload:是否自动上传
>
> action: 服务器接口路径
>
> name: 上传的文件字段名
>
> headers: 设置上传的请求头
>
> on-success: 上传成功的回调函数

```vue
<el-form-item label="文章封面">

                    <!-- 
                        auto-upload:设置是否自动上传
                        action:设置服务器接口路径
                        name:设置上传的文件字段名
                        headers:设置上传的请求头
                        on-success:设置上传成功的回调函数
                     -->
                   
                    <el-upload class="avatar-uploader" :auto-upload="true" :show-file-list="false"
                    action="/api/upload"
                    name="file"
                    :headers="{'Authorization':tokenStore.token}"
                    :on-success="uploadSuccess"
                    >
                        <img v-if="articleModel.coverImg" :src="articleModel.coverImg" class="avatar" />
                        <el-icon v-else class="avatar-uploader-icon">
                            <Plus />
                        </el-icon>
                    </el-upload>
                </el-form-item>

```

### 绑定上传函数

> uploadSuccess

```js
//上传成功的回调函数
const uploadSuccess = (result)=>{
    articleModel.value.coverImg = result.data;
    console.log(result.data);
}
```

### 接口调用

> **article.js中提供添加文章函数**

```js
//添加文章
export const articleAddService = (articleModel)=>{
    return request.post('/article',articleModel)
}
```

> **为已发布和草稿按钮绑定事件**

```vue
<el-form-item>
    <el-button type="primary" @click="addArticle('已发布')">发布</el-button>
    <el-button type="info" @click="addArticle('草稿')">草稿</el-button>
</el-form-item>
```

> **ArticleManage.vue中提供addArticle函数完成添加文章接口的调用**

```js
import { articleAddService } from '@/api/article.js'
//添加文章
const addArticle=async (state)=>{
    articleModel.value.state = state
    let result = await articleAddService(articleModel.value);
    ElMessage.success(result.message? result.message:'添加成功')
    //再次调用getArticles,获取文章
    getArticles()
    //隐藏抽屉
    visibleDrawer.value=false
}
```

## 文章删除

#### 删除按钮绑定事件

```vue
  <el-button :icon="Delete" circle plain type="danger" @click="deleteArticle(row)"></el-button>
```

#### 接口调用

```js
//删除文章
export const articleDeleteService = (id)=>{
    return request.delete('/article/id='+id)
}
```

#### 对话框弹窗

```js
import { ElMessageBox } from 'element-plus'
import { articleDeleteService } from '@/api/article.js'
//删除文章
const deleteArticle = (row) => {
    ElMessageBox.confirm(
        '你确认删除该文章信息吗？',
        '温馨提示',
        {
            confirmButtonText: '确认',
            cancelButtonText: '取消',
            type: 'warning',
        }
    )
        .then(async () => {
            //用户点击了确认
            let result = await articleDeleteService(row.id)
            ElMessage.success('删除成功')
            //再次调用getArticles，获取所有文章
            getArticles()
        })
        .catch(() => {
            //用户点击了取消
            ElMessage({
                type: 'info',
                message: '取消删除',
            })
        })
}
```

## 修改文章

### 弹窗显示

> 在Article.vue中初始化一个标题属性

```js
//弹窗标题
const title=ref('')
```

### 在弹窗上绑定标题

> 每次对话框中的标题都从属性中获取

```vue
<el-drawer v-model="visibleDrawer" :title="title" direction="rtl" size="50%">
```

### 数据回显

> 当点击修改按钮的时候，需要把详细信息回显到框中，通过插槽的方式得到被点击按钮所在行的数据，row代表是行数

```vue
<el-table-column label="操作" width="100">
                <template #default="{ row }">
                    <el-button :icon="Edit" circle plain type="primary" @click="updateArticleEcho(row)"></el-button>
                    <el-button :icon="Delete" circle plain type="danger" @click="deleteArticle(row)"></el-button>
                </template>
            </el-table-column>
```

### 回显函数

> 把之前的属性放在了一起，在这个函数中
>
> 这个是字段信息，已有
>
> ```js
> //添加表单数据模型
> const articleModel = ref({
>  title: '',
>  categoryId: '',
>  coverImg: '',
>  content: '',
>  state: ''
> })
> ```
>
> 

```js
//修改文章回显
const updateArticleEcho = (row) => {
    title.value = '修改文章'
    dialogVisible.value = true
    //将row中的数据赋值给articleModel
    articleModel.value.title = row.title
    articleModel.value.categoryId =row.categoryId
    articleModel.value.coverImg =row.coverImg
    articleModel.value.content =row.content
    articleModel.value.state =row.state
    //修改的时候必须传递分类的id，所以扩展一个id属性
    articleModel.value.id=row.id
}
```

### 引入接口

> 在article.js中提供修改文章的函数

```js
//修改文章
export const articleUpdateService = (articleModel)=>{
    return request.put('/article',articleModel)
}
```

### 修改确定按钮的绑定事件

> 复用对话框的确认
>

```vue
                <el-form-item >
                    <el-button type="primary" @click="title==='添加文章'? addArticle('已发布'):updateArticle('已发布')">发布</el-button>
                    <el-button type="info" @click="title==='添加文章'? addArticle('草稿'):updateArticle('草稿')">草稿</el-button>
                </el-form-item>
```

### 调用接口完成修改的函数

```js
//修改文章
import { articleUpdateService } from '@/api/article.js'
const updateArticle=async ()=>{
    let result = await articleUpdateService(articleModel.value)
    ElMessage.success('修改成功')
    //隐藏弹窗
    dialogVisible.value=false
    //再次访问后台接口，查询所有文章
    getArticles()
}
```

### 修改和新增共用数据模型兼容

> 添加分类，并不希望回显数据，使用函数清空

```js
//清空模型数据
const clearArticleModel = ()=>{
    articleModel.value.title='',
    articleModel.value.categoryId='',
    articleModel.value.coverImg='',
    articleModel.value.content='',
    articleModel.value.state=''
}
```

> 调用

```vue
                <el-form-item >
                    <el-button type="primary" @click="title==='添加文章'? addArticle('已发布'):updateArticle('已发布')">发布</el-button>
                    <el-button type="info" @click="title==='添加文章'? addArticle('草稿'):updateArticle('草稿')">草稿</el-button>
                </el-form-item>
```
# 用户

## 用户信息存储

### 添加接口

```js
//获取个人信息
export const userInfoGetService = ()=>{
    return request.get('/user/userInfo');
}
```

### 定义个人中心状态

> src/stores/user.js中

```js
import { defineStore } from "pinia"
import {ref} from 'vue'

export const useUserInfoStore = defineStore('userInfo',()=>{
    //1.定义用户信息
    const info = ref({})
    //2.定义修改用户信息的方法
    const setInfo = (newInfo)=>{
        info.value = newInfo
    }
    //3.定义清空用户信息的方法
    const removeInfo = ()=>{
        info.value={}
    }

    return{info,setInfo,removeInfo}
},{
    persist:true
})
```

### Layout.vue中获取个人信息，并存储到pinia中

```js
//导入接口函数
import {userInfoGetService} from '@/api/user.js'
//导入pinia
import {useUserInfoStore} from '@/stores/user.js'
const userInfoStore = useUserInfoStore();
import {ref} from 'vue'

//获取个人信息
const getUserInf = async ()=>{
    let result = await userInfoGetService();
    //存储pinia
    userInfoStore.info =result.data;
}
getUserInf()
```

### **Layout.vue的顶部导航栏中，展示昵称和头像**

```vue
<div>黑马程序员：<strong>{{ userInfoStore.info.username }}</strong></div>



<el-avatar :src="userInfoStore.info.userPic ? userInfoStore.info.userPic : avatar" />
```



## 退出登录

### el-dropdown中功能实现

> 在el-dropdown中有四个子条目，分别是：
>
> - 基本资料
> - 更换头像
> - 重置密码
> - 退出登录
>
> 其中其三个起到路由功能，跟左侧菜单中【个人中心】下面的二级菜单是同样的功能，退出登录需要删除本地pinia中存储的token以及userInfo

### **路由实现**

在el-dropdown-item标签上添加command属性，属性值和路由表中/user/xxx保持一致

```vue
<el-dropdown-menu>
    <el-dropdown-item command="info" :icon="User">基本资料</el-dropdown-item>
    <el-dropdown-item command="avatar" :icon="Crop">更换头像</el-dropdown-item>
    <el-dropdown-item command="password" :icon="EditPen">重置密码</el-dropdown-item>
    <el-dropdown-item command="logout" :icon="SwitchButton">退出登录</el-dropdown-item>
</el-dropdown-menu>
```

完整代码：
```vue
<el-header>
                <div>黑马程序员：<strong>{{ userInfoStore.info.username }}</strong></div>
                <el-dropdown placement="bottom-end" @command="handleCommand">
                    <span class="el-dropdown__box">
                        <el-avatar :src="userInfoStore.info.userPic ? userInfoStore.info.userPic : avatar" />
                        <el-icon>
                            <CaretBottom />
                        </el-icon>
                    </span>
                    <template #dropdown>
                        <el-dropdown-menu>
                            <el-dropdown-item command="info" :icon="User">基本资料</el-dropdown-item>
                            <el-dropdown-item command="avatar" :icon="Crop">更换头像</el-dropdown-item>
                            <el-dropdown-item command="password" :icon="EditPen">重置密码</el-dropdown-item>
                            <el-dropdown-item command="logout" :icon="SwitchButton">退出登录</el-dropdown-item>
                        </el-dropdown-menu>
                    </template>
                </el-dropdown>
            </el-header>
```



在el-dropdown标签上绑定command事件,当有条目被点击后，会触发这个事件

```vue
<el-dropdown placement="bottom-end" @command="handleCommand">
```

提供handleCommand函数，参数为点击条目的command属性值

```js
//dropDown条目被点击后，回调的函数
import {useRouter} from 'vue-router'
const router = useRouter()
const handleCommand = (command)=>{
    if(command==='logout'){
        //退出登录
        alert('退出登录')
    }else{
        //路由
        router.push('/user/'+command)
    }
}
```

### **退出登录实现：**

```js
import {useRouter} from 'vue-router'
import {ElMessage,ElMessageBox} from 'element-plus'
import { useTokenStore } from '@/stores/token.js'
const tokenStore = useTokenStore()
const router = useRouter();
const handleCommand = (command)=>{
    if (command === 'logout') {
        //退出登录
        ElMessageBox.confirm(
            '你确认退出登录码？',
            '温馨提示',
            {
                confirmButtonText: '确认',
                cancelButtonText: '取消',
                type: 'warning',
            }
        )
            .then(async () => {
                //调用后端退出登录接口
                await userLogout();
                //用户点击了确认
                //清空pinia中的token和个人信息
                userInfoStore.info={}
                tokenStore.token=''        
                //跳转到登录页
                router.push('/login')
            })
            .catch(() => {
                //用户点击了取消
                ElMessage({
                    type: 'info',
                    message: '取消退出',
                })
            })
    }else{
    router.push('/user/'+command);
   }
}
```

### 接口调用

```js
import {userLogoutService} from '@/api/user.js'
const userLogout = async ()=>{
    let result = await userLogoutService();
    console.log(result);
}
```

### 接口定义

> user.js中定义

```js
//退出登录接口
export const userLogoutService = ()=>{
    return request.get('/user/logout');
}
```

## 基本信息

### 复制

> 下面代码复制到user/userInfo.vue中

```vue
<script setup>
import { ref } from 'vue'
const userInfo = ref({
    id: 0,
    username: 'zhangsan',
    nickname: 'zs',
    email: 'zs@163.com',
})
const rules = {
    nickname: [
        { required: true, message: '请输入用户昵称', trigger: 'blur' },
        {
            pattern: /^\S{3,16}$/,
            message: '昵称必须是3-16位的非空字符串',
            trigger: 'blur'
        }
    ],
    email: [
        { required: true, message: '请输入用户邮箱', trigger: 'blur' },
        { type: 'email', message: '邮箱格式不正确', trigger: 'blur' }
    ]
}
</script>
<template>
    <el-card class="page-container">
        <template #header>
            <div class="header">
                <span>基本资料</span>
            </div>
        </template>
        <el-row>
            <el-col :span="12">
                <el-form :model="userInfo" :rules="rules" label-width="100px" size="large">
                    <el-form-item label="登录名称">
                        <el-input v-model="userInfo.username" disabled></el-input>
                    </el-form-item>
                    <el-form-item label="用户昵称" prop="nickname">
                        <el-input v-model="userInfo.nickname"></el-input>
                    </el-form-item>
                    <el-form-item label="用户邮箱" prop="email">
                        <el-input v-model="userInfo.email"></el-input>
                    </el-form-item>
                    <el-form-item>
                        <el-button type="primary">提交修改</el-button>
                    </el-form-item>
                </el-form>
            </el-col>
        </el-row>
    </el-card>
</template>
```

### 表单数据回显

个人信息之前已经存储到了pinia中，只需要从pinia中获取个人信息，替换模板数据即可

```js
import { useUserInfoStore } from '@/stores/user.js';
const userInfoStore = useUserInfoStore()
const userInfo = ref({...userInfoStore.info})
```

### 接口调用

> user.js

```js
//修改个人信息
export const userInfoUpdateService = (userInfo)=>{
    return request.put('/user/update',userInfo)
}
```
### 为修改按钮绑定单击事件

``` vue
 <el-button type="primary" @click="updateUserInfo">提交修改</el-button>
```

### 提供更新用户信息函数

```js
//修改用户信息
import {userInfoUpdateService} from '@/api/user.js'
import { ElMessage } from 'element-plus';
const updateUserInfo = async ()=>{
    let result = await userInfoUpdateService(userInfo.value)
    ElMessage.success(result.message? result.message:'修改成功')
    //更新pinia中的数据
    userInfoStore.info.nickname=userInfo.value.nickname
    userInfoStore.info.email = userInfo.value.email
}

```

## 更换头像

### 代码复制

```vue
<script setup>
import { Plus, Upload } from '@element-plus/icons-vue'
import {ref} from 'vue'
import avatar from '@/assets/default.png'
const uploadRef = ref()

//用户头像地址
const imgUrl= avatar

</script>

<template>
    <el-card class="page-container">
        <template #header>
            <div class="header">
                <span>更换头像</span>
            </div>
        </template>
        <el-row>
            <el-col :span="12">
                <el-upload 
                    ref="uploadRef"
                    class="avatar-uploader" 
                    :show-file-list="false"
                    >
                    <img v-if="imgUrl" :src="imgUrl" class="avatar" />
                    <img v-else :src="avatar" width="278" />
                </el-upload>
                <br />
                <el-button type="primary" :icon="Plus" size="large"  @click="uploadRef.$el.querySelector('input').click()">
                    选择图片
                </el-button>
                <el-button type="success" :icon="Upload" size="large">
                    上传头像
                </el-button>
            </el-col>
        </el-row>
    </el-card>
</template>

<style lang="scss" scoped>
.avatar-uploader {
    :deep() {
        .avatar {
            width: 278px;
            height: 278px;
            display: block;
        }

        .el-upload {
            border: 1px dashed var(--el-border-color);
            border-radius: 6px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: var(--el-transition-duration-fast);
        }

        .el-upload:hover {
            border-color: var(--el-color-primary);
        }

        .el-icon.avatar-uploader-icon {
            font-size: 28px;
            color: #8c939d;
            width: 278px;
            height: 278px;
            text-align: center;
        }
    }
}
</style>
```

### 头像回显

```js
//读取用户信息
import {ref} from 'vue'
import {useUserInfoStore} from '@/stores/user.js'
const userInfoStore = useUserInfoStore()
const imgUrl=ref(userInfoStore.info.userPic)
```

### 上传图片

> 为el-upload指定属性值，分别有：
>
> - ​	action: 服务器接口路径
> - ​	headers: 设置请求头，需要携带token
> - ​	on-success: 上传成功的回调函数
> - ​	name: 上传图片的字段名称

```vue

<el-upload 
           class="avatar-uploader" 
           :show-file-list="false"
           :auto-upload="true"
           action="/api/upload"
           name="file"
           :headers="{'Authorization':tokenStore.token}"
           :on-success="uploadSuccess"
           >
    <img v-if="imgUrl" :src="imgUrl" class="avatar" />
    <img v-else src="@/assets/avatar.jpg" width="278" />
</el-upload>
```

### 调用上传函数

```js
//读取token信息
import {useTokenStore} from '@/stores/token.js'
const tokenStore = useTokenStore()

//图片上传成功的回调
const uploadSuccess = (result)=>{
    //回显图片
    imgUrl.value = result.data
}
```

### 上传按钮绑定单击事件

```vue
<el-button type="success" :icon="Upload" size="large" @click="updateAvatar">
    上传头像
</el-button>
```

### 提供updateAvatar函数，完成头像更新

```js
//调用接口，更新头像url
import {userAvatarUpdateService} from '@/api/user.js'
import {ElMessage} from 'element-plus'
const updateAvatar = async ()=>{
    let result = await userAvatarUpdateService(imgUrl.value)
    ElMessage.success(result.message? result.message:'修改成功')
    //更新pinia中的数据
    userInfoStore.info.userPic=imgUrl.value
}
```

### 提供上传头像的函数

> 在user.js中提供修改头像的函数

```js
//修改头像
export const userAvatarUpdateService=(avatarUrl)=>{
    let params = new URLSearchParams();
    params.append('avatarUrl',avatarUrl)
    return request.patch('/user/updateAvatar',params)
}
```

## 重置密码

### 修改密码页面

> 在UserResetPassword.vue复制下面代码

```vue
<script setup>
import { ref } from 'vue'
import { ElMessage } from 'element-plus'
import {useRouter} from 'vue-router'
const router = useRouter();
// 假设存在密码重置的API服务
import { resetPasswordService } from '@/api/user.js'

// 表单数据
const formData = ref({
  old_pwd: '',
  new_pwd: '',
  re_pwd: ''
})

// 验证规则
const rules = {
  old_pwd: [
    { required: true, message: '请输入旧密码', trigger: 'blur' },
    { min: 6, max: 20, message: '密码长度需在6-20位之间', trigger: 'blur' }
  ],
  new_pwd: [
    { required: true, message: '请输入新密码', trigger: 'blur' },
    { min: 6, max: 20, message: '密码长度需在6-20位之间', trigger: 'blur' }
  ],
  re_pwd: [
    { required: true, message: '请确认新密码', trigger: 'blur' },
    {
      validator: (rule, value, callback) => {
        if (value !== formData.value.new_pwd) {
          callback(new Error('两次输入的密码不一致'))
        } else {
          callback()
        }
      },
      trigger: 'blur'
    }
  ]
}

// 重置密码函数
const resetPassword = async () => {
  try {
    if (!formData.value.old_pwd || !formData.value.new_pwd || !formData.value.re_pwd) {
      ElMessage.error('请填写所有必填项')
      return 
    }
    await resetPasswordService(formData.value)
    ElMessage.success('密码重置成功')
    router.push('/login')
  } catch (error) {
    ElMessage.error('密码重置失败，请检查输入')
  }
}
</script>

<template>
  <el-card class="page-container">
    <template #header>
      <div class="header">
        <span>重置密码</span>
      </div>
    </template>
    <el-row>
      <el-col :span="12">
        <el-form 
          :model="formData" 
          :rules="rules" 
          label-width="100px" 
          size="large"
          ref="passwordForm"
        >
          <el-form-item label="旧密码" prop="old_pwd">
            <el-input 
              v-model="formData.old_pwd" 
              type="password" 
              show-password
            ></el-input>
          </el-form-item>
          <el-form-item label="新密码" prop="new_pwd">
            <el-input 
              v-model="formData.new_pwd" 
              type="password" 
              show-password
            ></el-input>
          </el-form-item>
          <el-form-item label="确认密码" prop="re_pwd">
            <el-input 
              v-model="formData.re_pwd" 
              type="password" 
              show-password
            ></el-input>
          </el-form-item>
          <el-form-item>
            <el-button 
              type="primary" 
              @click="resetPassword"
              :loading="isLoading"
            >
              确认修改
            </el-button>
          </el-form-item>
        </el-form>
      </el-col>
    </el-row>
  </el-card>
</template>

<style lang="scss" scoped>
/* 沿用之前的容器样式，无需重复定义 */
</style>
```

### 添加调用函数

```js
// 修改密码接口
export const resetPasswordService = (pwdData) => {
    return request.patch('/user/updatePwd', pwdData);
}
```

